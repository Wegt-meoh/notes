<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="description" content="introduce resolver in graphQL">
<meta name="author" content="lasting">
<title>Resolvers</title>
<style>
@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";
@import "https://cdn.jsdelivr.net/gh/asciidoctor/asciidoctor@2.0/data/stylesheets/asciidoctor-default.css";

section.red.bgc{
    color:aqua
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/a11y-light.min.css">
</head>
<body class="article toc2 toc-right data-line-1">
<div id="header">
<h1>Resolvers</h1>
<div class="details">
<span id="author" class="author">lasting</span><br>
<span id="email" class="email"><a href="mailto:lastingcoder@qq.com" data-href="mailto:lastingcoder@qq.com">lastingcoder@qq.com</a></span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_code_first">Code first</a></li>
<li><a href="#_object_types">Object types</a></li>
<li><a href="#_code_first_resolver">Code first resolver</a></li>
<li><a href="#_query_type_names">Query type names</a></li>
<li><a href="#_query_decorator_options">Query decorator options</a></li>
<li><a href="#_args_decorator_options">Args decorator options</a></li>
<li><a href="#_dedicated_arguments_class">Dedicated arguments class</a></li>
<li><a href="#_class_inheritance">Class inheritance</a></li>
<li><a href="#_generics">Generics</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph data-line-11">
<p>this artical only cover code first,exclude schema first!</p>
</div>
</div>
</div>
<div class="sect1 data-line-13">
<h2 id="_code_first">Code first</h2>
<div class="sectionbody">
<div class="paragraph data-line-15">
<p>In the code first approach, we don&#8217;t follow the typical process of creating our GraphQL schema by writing GraphQL SDL by hand. Instead, we use TypeScript decorators to generate the SDL from TypeScript class definitions. The <strong><mark>@nestjs/graphql</mark></strong> package reads the metadata defined through the decorators and automatically generates the schema for you.</p>
</div>
</div>
</div>
<div class="sect1 data-line-17">
<h2 id="_object_types">Object types</h2>
<div class="sectionbody">
<div class="paragraph data-line-19">
<p>If we were using the schema first approach, we&#8217;d define such a schema with SDL like this:</p>
</div>
<div class="exampleblock data-line-21">
<div class="content">
<div class="listingblock data-line-22">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sdl hljs" data-lang="sdl">type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post!]!
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-32">
<p>In this case, using the code first approach, we define schemas using TypeScript classes and using TypeScript decorators to annotate the fields of those classes. The equivalent of the above SDL in the code first approach is:</p>
</div>
<div class="exampleblock data-line-34">
<div class="content">
<div class="listingblock data-line-35">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { Field, Int, ObjectType } from '@nestjs/graphql';
import { Post } from './post';

@ObjectType()
export class Author {
  @Field(type =&gt; Int)
  id: number;

  @Field({ nullable: true })
  firstName?: string;

  @Field({ nullable: true })
  lastName?: string;

  @Field(type =&gt; [Post])
  posts: Post[];
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip data-line-57">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-58">
<p>TypeScript&#8217;s metadata reflection system has several limitations which make it impossible, for instance, to determine what properties a class consists of or recognize whether a given property is optional or required. Because of these limitations, we must either explicitly use the <strong><mark>@Field()</mark></strong> decorator in our schema definition classes to provide metadata about each field&#8217;s GraphQL type and optionality, or use a <strong><mark>CLI plugin</mark></strong> to generate these for us.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-61">
<p>anothor example:</p>
</div>
<div class="exampleblock data-line-63">
<div class="content">
<div class="listingblock data-line-64">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { Field, Int, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class Post {
  @Field(type =&gt; Int)
  id: number;

  @Field()
  title: string;

  @Field(type =&gt; Int, { nullable: true })
  votes?: number;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock data-line-81">
<div class="content">
<div class="listingblock data-line-82">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sdl hljs" data-lang="sdl">type Post {
  id: Int!
  title: String!
  votes: Int
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-91">
<p><strong>The type function is required when there&#8217;s the potential for ambiguity between the TypeScript type system and the GraphQL type system.</strong> Specifically: it is <strong>not</strong> required for <strong><mark>string</mark></strong> and <strong><mark>boolean</mark></strong> types; it is required for <strong><mark>number</mark></strong> (which must be mapped to either a GraphQL <strong><mark>Int</mark></strong> or <strong><mark>Float</mark></strong>). The type function should simply return the desired GraphQL type (as shown in various examples in these chapters).</p>
</div>
<div class="paragraph data-line-93">
<p>The options object can have any of the following key/value pairs:</p>
</div>
<div class="ulist data-line-95">
<ul>
<li class="data-line-95">
<p><code>nullable</code>: for specifying whether a field is nullable (in SDL, each field is non-nullable by default); <mark>boolean</mark></p>
</li>
<li class="data-line-97">
<p><code>description</code>: for setting a field description; <mark>string</mark></p>
</li>
<li class="data-line-99">
<p><code>deprecationReason</code>: for marking a field as deprecated; <mark>string</mark></p>
</li>
</ul>
</div>
<div class="paragraph data-line-101">
<p>For example:</p>
</div>
<div class="exampleblock data-line-103">
<div class="content">
<div class="listingblock data-line-104">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Field({ description: `Book title`, deprecationReason: 'Not useful in v2 schema' })
title: string;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip data-line-111">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-112">
<p>You can also add a description to, or deprecate, the whole object type: <mark>@ObjectType({ description: 'Author model' })</mark>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-115">
<p>When the field is an array, we must manually indicate the array type in the Field() decorator&#8217;s type function, as shown below:</p>
</div>
<div class="exampleblock data-line-117">
<div class="content">
<div class="listingblock data-line-118">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Field(type =&gt; [Post])
posts: Post[];</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip data-line-125">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-126">
<p>Using array bracket notation (<mark>[ ]</mark>), we can indicate the depth of the array. For example, using <mark>[[Int]]</mark> would represent an integer matrix.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-129">
<p>To declare that an array&#8217;s items (not the array itself) are nullable, set the nullable property to 'items' as shown below:</p>
</div>
<div class="exampleblock data-line-131">
<div class="content">
<div class="listingblock data-line-132">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Field(type =&gt; [Post], { nullable: 'items' })
posts: Post[];</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip data-line-139">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-140">
<p>If both the array and its items are nullable, set <mark>nullable</mark> to <mark>'itemsAndList'</mark> instead.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-143">
<h2 id="_code_first_resolver">Code first resolver</h2>
<div class="sectionbody">
<div class="paragraph data-line-145">
<p>At this point, we&#8217;ve defined the objects (type definitions) that can exist in our data graph, but clients don&#8217;t yet have a way to interact with those objects. To address that, we need to create a resolver class. In the code first method, <strong>a resolver class both defines resolver functions and generates the Query type.</strong> This will be clear as we work through the example below:</p>
</div>
<div class="exampleblock data-line-149">
<div class="title">author/author.resolver.ts</div>
<div class="content">
<div class="listingblock data-line-150">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Resolver(of =&gt; Author)
export class AuthorsResolver {
  constructor(
    private authorsService: AuthorsService,
    private postsService: PostsService,
  ) {}

  @Query(returns =&gt; Author)
  async author(@Args('id', { type: () =&gt; Int }) id: number) {
    return this.authorsService.findOneById(id);
  }

  @ResolveField()
  async posts(@Parent() author: Author) {
    const { id } = author;
    return this.postsService.findAll({ authorId: id });
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-172">
<p>In our example, since the class includes a <strong><mark>field resolver</mark></strong> function (for the <code>posts</code> property of the <code>Author</code> object type), we must supply the <strong><mark>@Resolver()</mark></strong> decorator with a value to indicate which class is the parent type (i.e., the corresponding <strong><mark>ObjectType</mark></strong> class name) for all field resolvers defined within this class. As should be clear from the example, when writing a field resolver function, it&#8217;s necessary to access the parent object (the object the field being resolved is a member of). In this example, we populate an author&#8217;s posts array with a field resolver that calls a service which takes the author&#8217;s <strong><mark>id</mark></strong> as an argument. Hence the need to identify the parent object in the <strong><mark>@Resolver()</mark></strong> decorator. Note the corresponding use of the <strong><mark>@Parent()</mark></strong> method parameter decorator to then extract a reference to that parent object in the field resolver.</p>
</div>
</div>
</div>
<div class="sect1 data-line-174">
<h2 id="_query_type_names">Query type names</h2>
<div class="sectionbody">
<div class="exampleblock data-line-176">
<div class="content">
<div class="listingblock data-line-177">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Query(returns =&gt; Author)
async author(@Args('id', { type: () =&gt; Int }) id: number) {
  return this.authorsService.findOneById(id);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-185">
<p>This generates the following entry for the author query in our schema (the query type uses the same name as the method name):</p>
</div>
<div class="exampleblock data-line-187">
<div class="content">
<div class="listingblock data-line-188">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sdl hljs" data-lang="sdl">type Query {
  author(id: Int!): Author
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-195">
<p>Conventionally, we prefer to decouple these names; for example, we prefer to use a name like <strong><mark>getAuthor()</mark></strong> for our query handler method, but still use <strong><mark>author</mark></strong> for our query type name. The same applies to our field resolvers. We can easily do this by passing the mapping names as arguments of the <strong><mark>@Query()</mark></strong> and <strong><mark>@ResolveField()</mark></strong> decorators, as shown below:</p>
</div>
<div class="exampleblock data-line-197">
<div class="content">
<div class="listingblock data-line-198">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Resolver(of =&gt; Author)
export class AuthorsResolver {
  constructor(
    private authorsService: AuthorsService,
    private postsService: PostsService,
  ) {}

  @Query(returns =&gt; Author, { name: 'author' })
  async getAuthor(@Args('id', { type: () =&gt; Int }) id: number) {
    return this.authorsService.findOneById(id);
  }

  @ResolveField('posts', returns =&gt; [Post])
  async getPosts(@Parent() author: Author) {
    const { id } = author;
    return this.postsService.findAll({ authorId: id });
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-220">
<p>The getAuthor handler method above will result in generating the following part of the GraphQL schema in SDL:</p>
</div>
<div class="exampleblock data-line-222">
<div class="content">
<div class="listingblock data-line-223">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">type Query {
  author(id: Int!): Author
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-230">
<h2 id="_query_decorator_options">Query decorator options</h2>
<div class="sectionbody">
<div class="ulist data-line-232">
<ul>
<li class="data-line-232">
<p><code>name</code>: name of the query; a <code>string</code></p>
</li>
<li class="data-line-234">
<p><code>description</code>: a description that will be used to generate GraphQL schema documentation (e.g., in GraphQL playground); a <code>string</code></p>
</li>
<li class="data-line-236">
<p><code>deprecationReason</code>: sets query metadata to show the query as deprecated (e.g., in GraphQL playground); a <code>string</code></p>
</li>
<li class="data-line-238">
<p><code>nullable</code>: whether the query can return a null data response; <code>boolean</code> or <code>'items'</code> or <code>'itemsAndList'</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1 data-line-240">
<h2 id="_args_decorator_options">Args decorator options</h2>
<div class="sectionbody">
<div class="paragraph data-line-242">
<p>Use the <strong><mark>@Args()</mark></strong> decorator to extract arguments from a request for use in the method handler. This works in a very similar fashion to <strong>REST route parameter argument extraction</strong>.</p>
</div>
<div class="paragraph data-line-244">
<p>Usually your <strong><mark>@Args()</mark></strong> decorator will be simple, and not require an object argument as seen with the <strong><mark>getAuthor()</mark></strong> method above. For example, if the type of an identifier is string, the following construction is sufficient, and simply plucks the named field from the inbound GraphQL request for use as a method argument.</p>
</div>
<div class="exampleblock data-line-246">
<div class="content">
<div class="listingblock data-line-247">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Args('id') id: string</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-252">
<p>In the <strong><mark>getAuthor()</mark></strong> case, the <strong><mark>number</mark></strong> type is used, which presents a challenge. The number TypeScript type doesn&#8217;t give us enough information about the expected GraphQL representation (e.g., <strong><mark>Int</mark></strong> vs. <strong><mark>Float</mark></strong>). Thus we have to <strong>explicitly</strong> pass the type reference. We do that by passing a second argument to the <strong><mark>Args()</mark></strong> decorator, containing argument options, as shown below:</p>
</div>
<div class="exampleblock data-line-254">
<div class="content">
<div class="listingblock data-line-255">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Query(returns =&gt; Author, { name: 'author' })
async getAuthor(@Args('id', { type: () =&gt; Int }) id: number) {
  return this.authorsService.findOneById(id);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-263">
<p>The options object allows us to specify the following optional key value pairs:</p>
</div>
<div class="ulist data-line-265">
<ul>
<li class="data-line-265">
<p><code>type</code>: a function returning the GraphQL type</p>
</li>
<li class="data-line-267">
<p><code>defaultValue</code>: a default value; <code>any</code></p>
</li>
<li class="data-line-269">
<p><code>description</code>: description metadata; <code>string</code></p>
</li>
<li class="data-line-271">
<p><code>deprecationReason</code>: to deprecate a field and provide meta data describing why; <code>string</code></p>
</li>
<li class="data-line-273">
<p><code>nullable</code>: whether the field is nullable</p>
</li>
</ul>
</div>
<div class="paragraph data-line-275">
<p>Query handler methods can take multiple arguments. Let&#8217;s imagine that we want to fetch an author based on its <strong>firstName</strong> and <strong>lastName</strong>. In this case, we can call <strong><mark>@Args</mark></strong> twice:</p>
</div>
<div class="exampleblock data-line-277">
<div class="content">
<div class="listingblock data-line-278">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">getAuthor(
  @Args('firstName', { nullable: true }) firstName?: string,
  @Args('lastName', { defaultValue: '' }) lastName?: string,
) {}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-286">
<h2 id="_dedicated_arguments_class">Dedicated arguments class</h2>
<div class="sectionbody">
<div class="paragraph data-line-288">
<p>With inline <strong><mark>@Args()</mark></strong> calls, code like the example above becomes <strong>bloated</strong>. Instead, you can create a dedicated <strong><mark>GetAuthorArgs</mark></strong> arguments class and access it in the handler method as follows:</p>
</div>
<div class="exampleblock data-line-290">
<div class="content">
<div class="listingblock data-line-291">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Args() args: GetAuthorArgs</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-296">
<p>Create the <strong><mark>GetAuthorArgs</mark></strong> class using <strong><mark>@ArgsType()</mark></strong> as shown below:</p>
</div>
<div class="exampleblock data-line-300">
<div class="title">authors/dto/get-author.args.ts</div>
<div class="content">
<div class="listingblock data-line-301">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { MinLength } from 'class-validator';
import { Field, ArgsType } from '@nestjs/graphql';

@ArgsType()
class GetAuthorArgs {
  @Field({ nullable: true })
  firstName?: string;

  @Field({ defaultValue: '' })
  @MinLength(3)
  lastName: string;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip data-line-318">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-319">
<p>Again, due to TypeScript&#8217;s metadata reflection system limitations, it&#8217;s required to either use the <strong><mark>@Field</mark></strong> decorator to manually indicate type and optionality, or use a <strong><mark>CLI plugin</mark></strong>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-322">
<p>This will result in generating the following part of the GraphQL schema in SDL:</p>
</div>
<div class="exampleblock data-line-324">
<div class="content">
<div class="listingblock data-line-325">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sdl hljs" data-lang="sdl">type Query {
  author(firstName: String, lastName: String = ''): Author
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-332">
<h2 id="_class_inheritance">Class inheritance</h2>
<div class="sectionbody">
<div class="exampleblock data-line-336">
<div class="title">Base <strong><mark>@ArgsType()</mark></strong> class:</div>
<div class="content">
<div class="listingblock data-line-337">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@ArgsType()
class PaginationArgs {
  @Field((type) =&gt; Int)
  offset: number = 0;

  @Field((type) =&gt; Int)
  limit: number = 10;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock data-line-352">
<div class="title">Type specific sub-class of the base <strong><mark>@ArgsType()</mark></strong> class:</div>
<div class="content">
<div class="listingblock data-line-353">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@ArgsType()
class GetAuthorArgs extends PaginationArgs {
  @Field({ nullable: true })
  firstName?: string;

  @Field({ defaultValue: '' })
  @MinLength(3)
  lastName: string;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-366">
<p>The same approach can be taken with <strong><mark>@ObjectType()</mark></strong> objects. Define generic properties on the base class:</p>
</div>
<div class="exampleblock data-line-368">
<div class="content">
<div class="listingblock data-line-369">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@ObjectType()
class Character {
  @Field((type) =&gt; Int)
  id: number;

  @Field()
  name: string;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-381">
<p>Add type-specific properties on sub-classes:</p>
</div>
<div class="exampleblock data-line-383">
<div class="content">
<div class="listingblock data-line-384">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@ObjectType()
class Warrior extends Character {
  @Field()
  level: number;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-393">
<p>You can use inheritance with a resolver as well. You can ensure type safety by combining inheritance and TypeScript generics. For example, to create a base class with a generic <strong><mark>findAll</mark></strong> query, use a construction like this:</p>
</div>
<div class="exampleblock data-line-395">
<div class="content">
<div class="listingblock data-line-396">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">function BaseResolver&lt;T extends Type&lt;unknown&gt;&gt;(classRef: T): any {
  @Resolver({ isAbstract: true })
  abstract class BaseResolverHost {
    @Query((type) =&gt; [classRef], { name: `findAll${classRef.name}` })
    async findAll(): Promise&lt;T[]&gt; {
      return [];
    }
  }
  return BaseResolverHost;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note data-line-411">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist data-line-412">
<ul>
<li class="data-line-412">
<p>an explicit return type (<strong><mark>any</mark></strong> above) is required: otherwise TypeScript complains about the usage of a private class definition. Recommended: define an interface instead of using <strong><mark>any</mark></strong>.</p>
</li>
<li class="data-line-414">
<p><strong><mark>Type</mark></strong> is imported from the <strong><mark>@nestjs/common</mark></strong> package</p>
</li>
<li class="data-line-416">
<p>The <strong><mark>isAbstract: true</mark></strong> property indicates that SDL (Schema Definition Language statements) shouldn&#8217;t be generated for this class. Note, you can set this property for other types as well to suppress SDL generation.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-419">
<p>Here&#8217;s how you could generate a concrete sub-class of the <strong><mark>BaseResolver</mark></strong>:</p>
</div>
<div class="exampleblock data-line-421">
<div class="content">
<div class="listingblock data-line-422">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@Resolver((of) =&gt; Recipe)
export class RecipesResolver extends BaseResolver(Recipe) {
  constructor(private recipesService: RecipesService) {
    super();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-432">
<p>This construct would generated the following SDL:</p>
</div>
<div class="exampleblock data-line-434">
<div class="content">
<div class="listingblock data-line-435">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sdl hljs" data-lang="sdl">type Query {
  findAllRecipe: [Recipe!]!
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-442">
<h2 id="_generics">Generics</h2>
<div class="sectionbody">
<div class="paragraph data-line-444">
<p>We saw one use of generics above. This powerful TypeScript feature can be used to create useful abstractions. For example, here&#8217;s a sample cursor-based pagination implementation based on <a href="https://graphql.org/learn/pagination/#pagination-and-edges" data-href="https://graphql.org/learn/pagination/#pagination-and-edges">this documentation</a>:</p>
</div>
<div class="exampleblock data-line-446">
<div class="content">
<div class="listingblock data-line-447">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">import { Field, ObjectType, Int } from '@nestjs/graphql';
import { Type } from '@nestjs/common';

interface IEdgeType&lt;T&gt; {
  cursor: string;
  node: T;
}

export interface IPaginatedType&lt;T&gt; {
  edges: IEdgeType&lt;T&gt;[];
  nodes: T[];
  totalCount: number;
  hasNextPage: boolean;
}

export function Paginated&lt;T&gt;(classRef: Type&lt;T&gt;): Type&lt;IPaginatedType&lt;T&gt;&gt; {
  @ObjectType(`${classRef.name}Edge`)
  abstract class EdgeType {
    @Field((type) =&gt; String)
    cursor: string;

    @Field((type) =&gt; classRef)
    node: T;
  }

  @ObjectType({ isAbstract: true })
  abstract class PaginatedType implements IPaginatedType&lt;T&gt; {
    @Field((type) =&gt; [EdgeType], { nullable: true })
    edges: EdgeType[];

    @Field((type) =&gt; [classRef], { nullable: true })
    nodes: T[];

    @Field((type) =&gt; Int)
    totalCount: number;

    @Field()
    hasNextPage: boolean;
  }
  return PaginatedType as Type&lt;IPaginatedType&lt;T&gt;&gt;;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-492">
<p>With the above base class defined, we can now easily create specialized types that inherit this behavior. For example:</p>
</div>
<div class="exampleblock data-line-494">
<div class="content">
<div class="listingblock data-line-495">
<div class="content">
<pre class="highlightjs highlight"><code class="language-ts hljs" data-lang="ts">@ObjectType()
class PaginatedAuthor extends Paginated(Author) {}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-03-09 16:33:43 +0800
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>